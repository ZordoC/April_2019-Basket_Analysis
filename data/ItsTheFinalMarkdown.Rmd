---
title: "Basket Analysis for BlackWell"

author: "José Pedro Conceição,Kiko Sánchez , Eloi Cirera"
date: "March 25, 2019"
output: 

  html_document:
    toc: true
    toc_depth: 5
    toc_float: true
    theme: "cerulean" 
    code_folding: hide
---




```{r setup, include=FALSE}
  library('pacman')
  pacman::p_load(readr,here, stringr, readxl, plyr, caret, dplyr, doParallel,
                 lubridate, crayon, corrplot, ggplot2, e1071, reshape2, tidyverse, arules, arulesViz)



Data<-read.csv("/home/zordo/Documents/Ubiqum/R-M2Task4/RM2T4/data/ElectronidexTransactions2017.csv",
                         header=FALSE,sep=",") 

trans<-read.transactions("/home/zordo/Documents/Ubiqum/R-M2Task4/RM2T4/data/ElectronidexTransactions2017.csv",
                         format="basket",sep=",",rm.duplicates = TRUE) 
```
</br>
</br>
</br>

## Executive Summary 












## Technical-Section


### Pre-process 
</br>
</br>
First things first, we need to have ou data organized in a way we can manipulate it easy(or in a way we know how)
</br>
</br>
```{r}
Data$rownumber <- 1:nrow(Data)

DataReady <- melt(Data,"rownumber")

DataReady <-  DataReady %>%  filter(value != "") %>%
  arrange(rownumber) 

```
</br>
</br>
This line of code transforms the data into the following format 

```{r}
 DataReady[1:10,]
```
</br>
</br>
Now that we have the data in a way we can work on it, we can start splitting the data,we chose to split the data by customer type (B2B,B2C) 
</br>
For that I first changed the product names by their respective categories provided in the pdf file, and made rules to decided if it's a business or a customer transaction.
</br>
</br>

```{r}
Laptop <- grep(c("Laptop|Aspire|Chromebook|MacBook"),DataReady$value)
Desktop <- grep(c("Desktop|iMac"),DataReady$value)
Tablets <- grep(c("iPad|Tablet|Tab|kindle"),DataReady$value)
Monitor <- grep(c("Monitor"),DataReady$value)
Drives <- grep(c("Hard Drive"),DataReady$value)
Speakers <- grep(c("Speakers|Speaker|Sonos|Cyber Acoustics|DOSS"),DataReady$value)
Cables <- grep(c("Cable|HDMI Adapter"),DataReady$value)
ActiveHeadPhones <- grep(c("Apple Earpods|Monster Beats|Wireless Sports|In-Ear|APIE|Panasonic On-Ear Stereo Headphones RP-HT21|Philips Flexible Earhook Headphone|Panasonic On-Ear Stereo Headphones"),DataReady$value)
Acessories <- grep(c("Microsoft Office Home and Student 2016|Computer Game|Belkin Mouse Pad|Large Mouse Pad"),DataReady$value)
Printers <- grep(c("Epson Printer|HP Wireless Printer|Canon Office Printer|Brother Printer|DYMO Label Manker"),DataReady$value)
PrintersINk <- grep(c("Epson Black Ink|HP Black & Tri-color Ink|Canon Ink|Brother Printer Toner|DYMO Labeling Tape"),DataReady$value)
CStands <- grep(c("Halter Acrylic Monitor Stand|Height-Adjustable|Multi Media Stand|Full Motion Monitor Mount"),DataReady$value)
SmartHome <- grep(c("Apple TV|Google Home|Smart Light Bulb|Fire TV Stick|Roku Express"),DataReady$value)
Mouse <- grep(c("3-Button Mouse|Logitech Wireless Mouse|Logitech 3-button Mouse|Redragon Gaming Mouse|HP Wireless Mouse|Generic Black 3-Button|Slim Wireless Mouse|Microsoft Basic Optical Mouse|Wireless Portable Mouse|Gaming Mouse Professional"),DataReady$value)
Keyboard <- grep(c("HP USB Keyboard|Logitech Wireless Keyboard|Rii LED Keyboard|Logitech Keyboard|Backlit LED Gaming Keyboard|Dell Wired Keyboard|Apple Wired Keyboard|Apple Wireless Keyboard|Apple Magic Keyboard"),DataReady$value)
Combo <- grep(c("Logitech MK550 Wireless Wave Keyboard and Mouse Combo|Logitech Desktop MK120 Mouse and keyboard Combo|Logitech MK270 Wireless Keyboard and Mouse Combo|Dell KM117 Wireless Keyboard & Mouse|EagleTec Wireless Combo Keyboard and Mouse|Microsoft Wireless Comfort Keyboard and Mouse|Microsoft Wireless Desktop Keyboard and Mouse|Rii LED Gaming Keyboard & Mouse Combo|Logitech MK360 Wireless Keyboard and Mouse Combo"),DataReady$value)
ComputerHeadPhones <- grep(c("Zombie Gaming Headset|Logitech ClearChat Headset|Panasonic On-Ear Stereo Headphones RP-HT21|PC Gaming Headset|Kensington Headphones|Logitech Stereo Headset|Koss Home Headphones|Microsoft Headset|Ailihen Stereo Headphones|XIBERIA Gaming Headset"),DataReady$value)


```
</br>
</br>
This grabs the indices for each different product name.
</br>
Now with the indices we just need to replace the specific indices with the respective category as we want it o appear.
It should look something like this:
</br>
</br>
```{r}
DataReady$value -> Names
Names <- replace(Names,Laptop,"Laptop")
Names <- replace(Names,Desktop,"Desktop")
Names <- replace(Names,Tablets,"Tablet")
Names <- replace(Names,Monitor,"Monitor")
Names <- replace(Names,Keyboard,"Keyboard")
Names <- replace(Names,Drives,"Driver")
Names <- replace(Names,Speakers,"Speakers")
Names <- replace(Names,Cables,"Cables")
Names <- replace(Names,Combo,"Combo")
Names <- replace(Names,ActiveHeadPhones,"Active Headphone")
Names <- replace(Names,Acessories,"Acessories")
Names <- replace(Names,Printers,"Printer")
Names <- replace(Names,PrintersINk,"Printer Ink")
Names <- replace(Names,CStands,"Computer Stand")
Names <- replace(Names,SmartHome,"Smart-Home Device")
Names <- replace(Names,Mouse,"Mice")
Names <- replace(Names,ComputerHeadPhones,"Computer Headphone")
```
</br>
</br>
Data by category
</br>
</br>
```{r}
DataReady <- cbind(DataReady,Names)

DataByCategory <- DataReady[,c(1,3,4)]

DataByCategory[1:10,]

```

</br>
</br>
So now we just need to know which transactions have laptops, desktops etc . We can do this with the following code.
</br>
</br>

```{r}
# 
#  laptops <- c()
# 
#  for(i in 1:9835){
# 
#  laptops[i] <-sum(DataByCategory$rownumber == i  & DataByCategory =="Laptop")
# 
#  laptops
# 
#  }
# 
#   desktops <- c()
# 
#  for(i in 1:9835){
# 
#  desktops[i] <-sum(DataByCategory$rownumber == i  & DataByCategory =="Desktop")
# 
#    desktops
# 
#  }
# 
#  printers <- c()
# 
#  for(i in 1:9835){
# 
#   printers[i] <-sum(DataByCategory$rownumber == i  & DataByCategory =="Printer")
# 
# 
#  }
# 
# monitors <- c()
# 
#  for(i in 1:9835){
# 
#    monitors[i] <-sum(DataByCategory$rownumber == i  & DataByCategory =="Monitor")
# 
#    monitors
# 
#  }

```

</br>
For the sake of compiling this markdown, I will just load my already cutted files, the logic is the same,the problem is that it takes 10 minutes for this 4 loops, and it's not efficient to do it this way.
</br>
</br>
</br>
Now with the indices we just need to subset the data with some rules we define ourselves freely.
</br>
</br>
```{r}

DataTran_df<-as.data.frame(as(trans, "matrix"))
DTrue <- DataTran_df +0
MySum <- rowSums(DTrue)

DTrue <-cbind(DTrue,MySum)
Vector <- DTrue[,c("MySum")] > 6
View(Vector)
Indices <- which(Vector,TRUE)


MoreThan3laptops <- which(laptops >= 3)
MoreThan2desktops <- which(desktops >= 3) 
MoreThan2Printers <-which(printers>=2)
MoreThan3Monitors <-which(monitors>4 )

```


```{r}
BusinessIndices <- (c(MoreThan2desktops,MoreThan2Printers,MoreThan3laptops,MoreThan3Monitors))
DataTran_df<-as.data.frame(as(trans, "matrix"))

Data <- DataTran_df

Data$rownumber <- rownumber

B2b <- Data[BusinessIndices,]

B2b2 <- Data[Indices,]

B2b3 <- bind_rows(B2b,B2b2)

B2b3 <- unique(B2b3)



B2c <- Data[-BusinessIndices,]
B2c2 <- Data[-Indices,]

B2c3 <- bind_rows(B2c,B2c2)

B2c3 <-unique(B2c3)




```







